<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Responding to Changes with create_effect</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../02_getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../view/index.html"><strong aria-hidden="true">3.</strong> Building User Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../view/01_basic_component.html"><strong aria-hidden="true">3.1.</strong> A Basic Component</a></li><li class="chapter-item expanded "><a href="../view/02_dynamic_attributes.html"><strong aria-hidden="true">3.2.</strong> Dynamic Attributes</a></li><li class="chapter-item expanded "><a href="../view/03_components.html"><strong aria-hidden="true">3.3.</strong> Components and Props</a></li><li class="chapter-item expanded "><a href="../view/04_iteration.html"><strong aria-hidden="true">3.4.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="../view/05_forms.html"><strong aria-hidden="true">3.5.</strong> Forms and Inputs</a></li><li class="chapter-item expanded "><a href="../view/06_control_flow.html"><strong aria-hidden="true">3.6.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../view/07_errors.html"><strong aria-hidden="true">3.7.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../view/08_parent_child.html"><strong aria-hidden="true">3.8.</strong> Parent-Child Communication</a></li><li class="chapter-item expanded "><a href="../view/09_component_children.html"><strong aria-hidden="true">3.9.</strong> Passing Children to Components</a></li></ol></li><li class="chapter-item expanded "><a href="../reactivity/index.html"><strong aria-hidden="true">4.</strong> Reactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reactivity/working_with_signals.html"><strong aria-hidden="true">4.1.</strong> Working with Signals</a></li><li class="chapter-item expanded "><a href="../reactivity/14_create_effect.html" class="active"><strong aria-hidden="true">4.2.</strong> Responding to Changes with create_effect</a></li><li class="chapter-item expanded "><a href="../reactivity/interlude_functions.html"><strong aria-hidden="true">4.3.</strong> Interlude: Reactivity and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">6.</strong> Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../async/10_resources.html"><strong aria-hidden="true">6.1.</strong> Loading Data with Resources</a></li><li class="chapter-item expanded "><a href="../async/11_suspense.html"><strong aria-hidden="true">6.2.</strong> Suspense</a></li><li class="chapter-item expanded "><a href="../async/12_transition.html"><strong aria-hidden="true">6.3.</strong> Transition</a></li><li class="chapter-item expanded "><a href="../async/13_actions.html"><strong aria-hidden="true">6.4.</strong> Actions</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_projecting_children.html"><strong aria-hidden="true">7.</strong> Interlude: Projecting Children</a></li><li class="chapter-item expanded "><a href="../15_global_state.html"><strong aria-hidden="true">8.</strong> Global State Management</a></li><li class="chapter-item expanded "><a href="../router/index.html"><strong aria-hidden="true">9.</strong> Router</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../router/16_routes.html"><strong aria-hidden="true">9.1.</strong> Defining &lt;Routes/&gt;</a></li><li class="chapter-item expanded "><a href="../router/17_nested_routing.html"><strong aria-hidden="true">9.2.</strong> Nested Routing</a></li><li class="chapter-item expanded "><a href="../router/18_params_and_queries.html"><strong aria-hidden="true">9.3.</strong> Params and Queries</a></li><li class="chapter-item expanded "><a href="../router/19_a.html"><strong aria-hidden="true">9.4.</strong> &lt;A/&gt;</a></li><li class="chapter-item expanded "><a href="../router/20_form.html"><strong aria-hidden="true">9.5.</strong> &lt;Form/&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../interlude_styling.html"><strong aria-hidden="true">10.</strong> Interlude: Styling</a></li><li class="chapter-item expanded "><a href="../metadata.html"><strong aria-hidden="true">11.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="../ssr/index.html"><strong aria-hidden="true">12.</strong> Server Side Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ssr/21_cargo_leptos.html"><strong aria-hidden="true">12.1.</strong> cargo-leptos</a></li><li class="chapter-item expanded "><a href="../ssr/22_life_cycle.html"><strong aria-hidden="true">12.2.</strong> The Life of a Page Load</a></li><li class="chapter-item expanded "><a href="../ssr/23_ssr_modes.html"><strong aria-hidden="true">12.3.</strong> Async Rendering and SSR “Modes”</a></li><li class="chapter-item expanded "><a href="../ssr/24_hydration_bugs.html"><strong aria-hidden="true">12.4.</strong> Hydration Bugs</a></li></ol></li><li class="chapter-item expanded "><a href="../server/index.html"><strong aria-hidden="true">13.</strong> Working with the Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/25_server_functions.html"><strong aria-hidden="true">13.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="../server/26_extractors.html"><strong aria-hidden="true">13.2.</strong> Extractors</a></li><li class="chapter-item expanded "><a href="../server/27_response.html"><strong aria-hidden="true">13.3.</strong> Responses and Redirects</a></li></ol></li><li class="chapter-item expanded "><a href="../progressive_enhancement/index.html"><strong aria-hidden="true">14.</strong> Progressive Enhancement and Graceful Degradation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../progressive_enhancement/action_form.html"><strong aria-hidden="true">14.1.</strong> &lt;ActionForm/&gt;s</a></li></ol></li><li class="chapter-item expanded "><a href="../deployment.html"><strong aria-hidden="true">15.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="../appendix_reactive_graph.html"><strong aria-hidden="true">16.</strong> Appendix: How Does the Reactive System Work?</a></li><li class="chapter-item expanded "><a href="../appendix_binary_size.html"><strong aria-hidden="true">17.</strong> Appendix: Optimizing WASM Binary Size</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="responding-to-changes-with-create_effect"><a class="header" href="#responding-to-changes-with-create_effect">Responding to Changes with <code>create_effect</code></a></h1>
<p>We’ve made it this far without having mentioned half of the reactive system: effects.</p>
<p>Reactivity works in two halves: updating individual reactive values (“signals”) notifies the pieces of code that depend on them (“effects”) that they need to run again. These two halves of the reactive system are inter-dependent. Without effects, signals can change within the reactive system but never be observed in a way that interacts with the outside world. Without signals, effects run once but never again, as there’s no observable value to subscribe to. Effects are quite literally “side effects” of the reactive system: they exist to synchronize the reactive system with the non-reactive world outside it.</p>
<p>Hidden behind the whole reactive DOM renderer that we’ve seen so far is a function called <code>create_effect</code>.</p>
<p><a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_effect.html"><code>create_effect</code></a> takes a function as its argument. It immediately runs the function. If you access any reactive signal inside that function, it registers the fact that the effect depends on that signal with the reactive runtime. Whenever one of the signals that the effect depends on changes, the effect runs again.</p>
<pre><code class="language-rust">let (a, set_a) = create_signal(cx, 0);
let (b, set_b) = create_signal(cx, 0);

create_effect(cx, move |_| {
  // immediately prints &quot;Value: 0&quot; and subscribes to `a`
  log::debug!(&quot;Value: {}&quot;, a());
});</code></pre>
<p>The effect function is called with an argument containing whatever value it returned the last time it ran. On the initial run, this is <code>None</code>.</p>
<p>By default, effects <strong>do not run on the server</strong>. This means you can call browser-specific APIs within the effect function without causing issues. If you need an effect to run on the server, use <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_isomorphic_effect.html"><code>create_isomorphic_effect</code></a>.</p>
<h2 id="autotracking-and-dynamic-dependencies"><a class="header" href="#autotracking-and-dynamic-dependencies">Autotracking and Dynamic Dependencies</a></h2>
<p>If you’re familiar with a framework like React, you might notice one key difference. React and similar frameworks typically require you to pass a “dependency array,” an explicit set of variables that determine when the effect should rerun.</p>
<p>Because Leptos comes from the tradition of synchronous reactive programming, we don’t need this explicit dependency list. Instead, we automatically track dependencies depending on which signals are accessed within the effect.</p>
<p>This has two effects (no pun intended). Dependencies are:</p>
<ol>
<li><strong>Automatic</strong>: You don’t need to maintain a dependency list, or worry about what should or shouldn’t be included. The framework simply tracks which signals might cause the effect to rerun, and handles it for you.</li>
<li><strong>Dynamic</strong>: The dependency list is cleared and updated every time the effect runs. If your effect contains a conditional (for example), only signals that are used in the current branch are tracked. This means that effects rerun the absolute minimum number of times.</li>
</ol>
<blockquote>
<p>If this sounds like magic, and if you want a deep dive into how automatic dependency tracking works, <a href="https://www.youtube.com/watch?v=GWB3vTWeLd4">check out this video</a>. (Apologies for the low volume!)</p>
</blockquote>
<h2 id="effects-as-zero-cost-ish-abstraction"><a class="header" href="#effects-as-zero-cost-ish-abstraction">Effects as Zero-Cost-ish Abstraction</a></h2>
<p>While they’re not a “zero-cost abstraction” in the most technical sense—they require some additional memory use, exist at runtime, etc.—at a higher level, from the perspective of whatever expensive API calls or other work you’re doing within them, effects are a zero-cost abstraction. They rerun the absolute minimum number of times necessary, given how you’ve described them.</p>
<p>Imagine that I’m creating some kind of chat software, and I want people to be able to display their full name, or just their first name, and to notify the server whenever their name changes:</p>
<pre><code class="language-rust">let (first, set_first) = create_signal(cx, String::new());
let (last, set_last) = create_signal(cx, String::new());
let (use_last, set_use_last) = create_signal(cx, true);

// this will add the name to the log
// any time one of the source signals changes
create_effect(cx, move |_| {
    log(
        cx,
        if use_last() {
            format!(&quot;{} {}&quot;, first(), last())
        } else {
            first()
        },
    )
});</code></pre>
<p>If <code>use_last</code> is <code>true</code>, effect should rerun whenever <code>first</code>, <code>last</code>, or <code>use_last</code> changes. But if I toggle <code>use_last</code> to <code>false</code>, a change in <code>last</code> will never cause the full name to change. In fact, <code>last</code> will be removed from the dependency list until <code>use_last</code> toggles again. This saves us from sending multiple unnecessary requests to the API if I change <code>last</code> multiple times while <code>use_last</code> is still <code>false</code>.</p>
<h2 id="to-create_effect-or-not-to-create_effect"><a class="header" href="#to-create_effect-or-not-to-create_effect">To <code>create_effect</code>, or not to <code>create_effect</code>?</a></h2>
<p>Effects are intended to run <em>side-effects</em> of the system, not to synchronize state <em>within</em> the system. In other words: don’t write to signals within effects.</p>
<p>If you need to define a signal that depends on the value of other signals, use a derived signal or <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.create_memo.html"><code>create_memo</code></a>.</p>
<p>If you need to synchronize some reactive value with the non-reactive world outside—like a web API, the console, the filesystem, or the DOM—create an effect.</p>
<blockquote>
<p>If you’re curious for more information about when you should and shouldn’t use <code>create_effect</code>, <a href="https://www.youtube.com/watch?v=aQOFJQ2JkvQ">check out this video</a> for a more in-depth consideration!</p>
</blockquote>
<h2 id="effects-and-rendering"><a class="header" href="#effects-and-rendering">Effects and Rendering</a></h2>
<p>We’ve managed to get this far without mentioning effects because they’re built into the Leptos DOM renderer. We’ve seen that you can create a signal and pass it into the <code>view</code> macro, and it will update the relevant DOM node whenever the signal changes:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(cx, 0);

view! { cx,
    &lt;p&gt;{count}&lt;/p&gt;
}</code></pre>
<p>This works because the framework essentially creates an effect wrapping this update. You can imagine Leptos translating this view into something like this:</p>
<pre><code class="language-rust">let (count, set_count) = create_signal(cx, 0);

// create a DOM element
let p = create_element(&quot;p&quot;);

// create an effect to reactively update the text
create_effect(cx, move |prev_value| {
    // first, access the signal’s value and convert it to a string
    let text = count().to_string();

    // if this is different from the previous value, update the node
    if prev_value != Some(text) {
        p.set_text_content(&amp;text);
    }

    // return this value so we can memoize the next update
    text
});</code></pre>
<p>Every time <code>count</code> is updated, this effect wil rerun. This is what allows reactive, fine-grained updates to the DOM.</p>
<h2 id="explicit-cancelable-tracking-with-watch"><a class="header" href="#explicit-cancelable-tracking-with-watch">Explicit, Cancelable Tracking with <code>watch</code></a></h2>
<p>In addition to <code>create_effect</code>, Leptos provides a <a href="https://docs.rs/leptos_reactive/latest/leptos_reactive/fn.watch.html"><code>watch</code></a> function, which can be used for two main purposes:</p>
<ol>
<li>Separating tracking and responding to changes by explicitly passing in a set of values to track.</li>
<li>Canceling tracking by calling a stop function.</li>
</ol>
<p>Like <code>create_resource</code>, <code>watch</code> takes a first argument, which is reactively tracked, and a second, which is not. Whenever a reactive value in its <code>deps</code> argument is changed, the <code>callback</code> is run. <code>watch</code> returns a function that can be called to stop tracking the dependencies.</p>
<pre><code class="language-rust">let (num, set_num) = create_signal(cx, 0);

let stop = watch(
    cx,
    move || num.get(),
    move |num, prev_num, _| {
        log::debug!(&quot;Number: {}; Prev: {:?}&quot;, num, prev_num);
    },
    false,
);

set_num.set(1); // &gt; &quot;Number: 1; Prev: Some(0)&quot;

stop(); // stop watching

set_num.set(2); // (nothing happens)</code></pre>
<p><a href="https://codesandbox.io/p/sandbox/serene-thompson-40974n?file=%2Fsrc%2Fmain.rs&amp;selection=%5B%7B%22endColumn%22%3A1%2C%22endLineNumber%22%3A2%2C%22startColumn%22%3A1%2C%22startLineNumber%22%3A2%7D%5D">Click to open CodeSandbox.</a></p>
<iframe src="https://codesandbox.io/p/sandbox/serene-thompson-40974n?file=%2Fsrc%2Fmain.rs&selection=%5B%7B%22endColumn%22%3A1%2C%22endLineNumber%22%3A2%2C%22startColumn%22%3A1%2C%22startLineNumber%22%3A2%7D%5D" width="100%" height="1000px" style="max-height: 100vh"></iframe>
<details>
<summary>CodeSandbox Source</summary>
<pre><code class="language-rust">use leptos::html::Input;
use leptos::*;

#[component]
fn App(cx: Scope) -&gt; impl IntoView {
    // Just making a visible log here
    // You can ignore this...
    let log = create_rw_signal::&lt;Vec&lt;String&gt;&gt;(cx, vec![]);
    let logged = move || log().join(&quot;\n&quot;);
    provide_context(cx, log);

    view! { cx,
        &lt;CreateAnEffect/&gt;
        &lt;pre&gt;{logged}&lt;/pre&gt;
    }
}

#[component]
fn CreateAnEffect(cx: Scope) -&gt; impl IntoView {
    let (first, set_first) = create_signal(cx, String::new());
    let (last, set_last) = create_signal(cx, String::new());
    let (use_last, set_use_last) = create_signal(cx, true);

    // this will add the name to the log
    // any time one of the source signals changes
    create_effect(cx, move |_| {
        log(
            cx,
            if use_last() {
                format!(&quot;{}  {}&quot;, first(), last())
            } else {
                first()
            },
        )
    });

    view! { cx,
        &lt;h1&gt;&lt;code&gt;&quot;create_effect&quot;&lt;/code&gt; &quot; Version&quot;&lt;/h1&gt;
        &lt;form&gt;
            &lt;label&gt;
                &quot;First Name&quot;
                &lt;input type=&quot;text&quot; name=&quot;first&quot; prop:value=first
                    on:change=move |ev| set_first(event_target_value(&amp;ev))
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Last Name&quot;
                &lt;input type=&quot;text&quot; name=&quot;last&quot; prop:value=last
                    on:change=move |ev| set_last(event_target_value(&amp;ev))
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Show Last Name&quot;
                &lt;input type=&quot;checkbox&quot; name=&quot;use_last&quot; prop:checked=use_last
                    on:change=move |ev| set_use_last(event_target_checked(&amp;ev))
                /&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    }
}

#[component]
fn ManualVersion(cx: Scope) -&gt; impl IntoView {
    let first = create_node_ref::&lt;Input&gt;(cx);
    let last = create_node_ref::&lt;Input&gt;(cx);
    let use_last = create_node_ref::&lt;Input&gt;(cx);

    let mut prev_name = String::new();
    let on_change = move |_| {
        log(cx, &quot;      listener&quot;);
        let first = first.get().unwrap();
        let last = last.get().unwrap();
        let use_last = use_last.get().unwrap();
        let this_one = if use_last.checked() {
            format!(&quot;{} {}&quot;, first.value(), last.value())
        } else {
            first.value()
        };

        if this_one != prev_name {
            log(cx, &amp;this_one);
            prev_name = this_one;
        }
    };

    view! { cx,
        &lt;h1&gt;&quot;Manual Version&quot;&lt;/h1&gt;
        &lt;form on:change=on_change&gt;
            &lt;label&gt;
                &quot;First Name&quot;
                &lt;input type=&quot;text&quot; name=&quot;first&quot;
                    node_ref=first
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Last Name&quot;
                &lt;input type=&quot;text&quot; name=&quot;last&quot;
                    node_ref=last
                /&gt;
            &lt;/label&gt;
            &lt;label&gt;
                &quot;Show Last Name&quot;
                &lt;input type=&quot;checkbox&quot; name=&quot;use_last&quot;
                    checked
                    node_ref=use_last
                /&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    }
}

#[component]
fn EffectVsDerivedSignal(cx: Scope) -&gt; impl IntoView {
    let (my_value, set_my_value) = create_signal(cx, String::new());
    // Don't do this.
    /*let (my_optional_value, set_optional_my_value) = create_signal(cx, Option::&lt;String&gt;::None);

    create_effect(cx, move |_| {
        if !my_value.get().is_empty() {
            set_optional_my_value(Some(my_value.get()));
        } else {
            set_optional_my_value(None);
        }
    });*/

    // Do this
    let my_optional_value =
        move || (!my_value.with(String::is_empty)).then(|| Some(my_value.get()));

    view! { cx,
        &lt;input
            prop:value=my_value
            on:input= move |ev| set_my_value(event_target_value(&amp;ev))
        /&gt;

        &lt;p&gt;
            &lt;code&gt;&quot;my_optional_value&quot;&lt;/code&gt;
            &quot; is &quot;
            &lt;code&gt;
                &lt;Show
                    when=move || my_optional_value().is_some()
                    fallback=|cx| view! { cx, &quot;None&quot; }
                &gt;
                    &quot;Some(\&quot;&quot; {my_optional_value().unwrap()} &quot;\&quot;)&quot;
                &lt;/Show&gt;
            &lt;/code&gt;
        &lt;/p&gt;
    }
}

/*#[component]
pub fn Show&lt;F, W, IV&gt;(
    /// The scope the component is running in
    cx: Scope,
    /// The components Show wraps
    children: Box&lt;dyn Fn(Scope) -&gt; Fragment&gt;,
    /// A closure that returns a bool that determines whether this thing runs
    when: W,
    /// A closure that returns what gets rendered if the when statement is false
    fallback: F,
) -&gt; impl IntoView
where
    W: Fn() -&gt; bool + 'static,
    F: Fn(Scope) -&gt; IV + 'static,
    IV: IntoView,
{
    let memoized_when = create_memo(cx, move |_| when());

    move || match memoized_when.get() {
        true =&gt; children(cx).into_view(cx),
        false =&gt; fallback(cx).into_view(cx),
    }
}*/

fn log(cx: Scope, msg: impl std::fmt::Display) {
    let log = use_context::&lt;RwSignal&lt;Vec&lt;String&gt;&gt;&gt;(cx).unwrap();
    log.update(|log| log.push(msg.to_string()));
}

fn main() {
    leptos::mount_to_body(|cx| view! { cx, &lt;App/&gt; })
}
</code></pre>
</details>
</preview>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reactivity/working_with_signals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../reactivity/interlude_functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reactivity/working_with_signals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../reactivity/interlude_functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
